# 1. 템플릿 메소드 패턴 :: 알고리즘 캡슐화하기

---

`템플릿 메소드 패턴(Template Method Pattern)`은 알고리즘의 골격을 정의한다. 알고리즘의 구조는 그대로 유지하면서 특정 단계를 서브클래스에서 재정의할 수 있다.

## 1.1 템플릿 메소드 구조

```java
상위 클래스
ㄴ템플릿 메서드 (고정된 순서)
ㄴㄴ공통 동작(상위 구현)
ㄴㄴ유동 동작(하위 구현)
```

템플릿 메소드 패턴은 이러한 구성을 가진다.

- 템플릿 메서드는 `final`로 정의하여 **서브 클래스에서 오버라이드 되지 않도록** 한다.
- **유동 동작(재료 추가, 우려내기)는 서브클래스에서 정의** 되기 때문에 `abstrac`로 선언 된다.
그렇기에 상위 클래스는 자연스럽게 추상 클래스가 된다.

## 1.2 템플릿 메소드 패턴 예시 : 커피와 홍차

<aside>

[커피 만드는 법]

1. 물을 끓인다.
2. 끓는 물에 커피를 우려낸다.
3. 커피를 컵에 따른다.
4. 설탕과 우유를 추가한다.
</aside>

<aside>

[홍차 만드는 법]

1. 물을 끓인다.
2. 끓는 물에 찻잎을 우려낸다.
3. 홍차를 컵에 따른다.
4. 레몬을 추가한다.
</aside>

- **완전히 동일한 것** : 물 끓이기, 컵에 따르기
- **재료만 다를 뿐 거의 유사한 것** : 커피/차 우려내기, 설탕·우유/레몬 추가하기

*→ 여기서 동일한 것을 추려내 **추상화** 하도록 한다.*

### 템플릿 메서드 패턴이 적용된 코드

**<CaffeinBeverge>**

```java
public abstract class CaffeinBeverage { 

// 템플릿 메소드
	final void prepareRecipe() { 
	    	boidWater();
	      brewCoffeeGrinds();
        pourInCup();
        addSugarAndMilk();
    }
    
    // 서브 클래스에서 정의될 유동 동작
	  abstract void brew() {}
	  
	  abstract void addCondiments() {}
  
	  // 재정의 되지 않는 공통 동작
    void boilWater() { 
    	System.out.println("물 끓이는 중");
    }
		
		void pourInCup() { 
    	System.out.println("컵에 따르는 중");
    }
   
}
```

<Coffee>

```java
public class Coffee extends CaffeineBeverage {
	public void brew() {
    	System.out.println("필터로 커피를 우려내는 중");
    }
    public void addCondiments() {
    	System.out.println("설탕과 우유 추가 중");
    }
}
```

<Tea>

```java
public class Tea extends CaffeineBeverage {
	public void brew() {
    	System.out.println("찻잎을 우려내는 중");
    }
    public void addCondiments() {
    	System.out.println("레몬 추가 중");
    }
}
```

# 2. 템플릿 메소드 속 후크

---

`후크(hook)`는 추상 클래스에서 선언되지만 기본적인 내용만 구현되어 있거나, 아무 코드도 들어있지 않은 메소드다.

1. **알고리즘에서 필수적이지 않은 부분을 서브클래스에서 구현**하도록 만들고 싶을 때 사용
2. 템플릿 메소드에서 앞으로 일어날 일이나 막 일어난 일에 서브클래스가 반응할 수 있도록 기회를 제공
3. 서브클래스가 추상 클래스에서 진행되는 작업을 처리할지말지 결정하게 하는 기능을 부여

## 2.1 예제 시나리오: 음료 만들기

hook 값에 따라 재료 추가 메소드 사용 여부가 달라진다.

```java
public abstract class CaffeineBeverage {
    // 템플릿 메서드
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {  // hook 사용
            addCondiments();
        }
    }

    void boilWater() {
        System.out.println("물 끓이는 중");
    }

    void pourInCup() {
        System.out.println("컵에 따르는 중");
    }

    abstract void brew();
    abstract void addCondiments();

    // ✅ Hook: 서브 클래스가 필요하면 오버라이딩
    boolean customerWantsCondiments() {
        return true; // 기본값은 첨가물 추가
    }
}
```

---

```java
public class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("찻잎을 우리는 중");
    }

    @Override
    void addCondiments() {
        System.out.println("레몬 추가");
    }
}
```

---

```java
public class BlackCoffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("커피 원두 우리는 중");
    }

    @Override
    void addCondiments() {
        System.out.println("설탕과 우유 추가");
    }

    // ✅ Hook 오버라이딩 → 첨가물 없이 블랙커피!
    @Override
    boolean customerWantsCondiments() {
        return false;
    }
}
```

---

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("[티 만들기]");
        CaffeineBeverage tea = new Tea();
        tea.prepareRecipe();

        System.out.println("\n[블랙커피 만들기]");
        CaffeineBeverage blackCoffee = new BlackCoffee();
        blackCoffee.prepareRecipe();
    }
}
```

### 주의 사항!

템플릿 메소드를 만들 때는 **추상 메소드가 너무 많아지지 않게** 고려해야 한다. (관리해야할 추상 메소드가 너무 많아지면 안 되기 때문) 이때 꼭 필요한 메소드가 아니라면 후크로 구현하는 것이 하나의 방법이다.

# 2. 할리우드 원칙 (Hollywood Principle)

---

**할리우드 원칙**이란 고수준 구성요소만 저수준 구성요소를 참조할 수 있는 원칙이다. 이를 통해, 의존성 부패를 방지할 수 있다.

- **의존성 부패** : 고수준 구성요소와 저수준 구성요소가 뒤섞여 서로를 참조하는 것.

## 2.1 템플릿 메소드 패턴의 할리우드 원칙

- **상위 클래스** : 고수준 구성 요소
- **서브 클래스** : 저수준 구성 요소로 메소드를 제공할 때만 이용된다. 상위 class에서 호출하지 않는 이상 절대 먼저 상위 class를 호출하지 않는다.

# 3. 자바 API속 템플릿 메소드 패턴 알아보기

---

자바 API 속 대표적인 템플릿 메소드 패턴으로는 Arrays.sort(배열 정렬)이 있다.

- `sort()`: 전체적인 정렬 순서 관장
- `CompareTo()` : sort() 내부에서 정렬 기준 정의

sort() 는 정적 메소드로 정의 되기 때문에 Comparable interface를 도입해 내부 CompareTo()가 정의 되었는지 파악한다.

**CompareTo() 를 정의하는 두 가지 방법**

- 배열요소 class에서 Compateble<T>를 이용한 구현
- 사용하는 외부에서 `@Override`를 이용해 Comprator 전달

### 추가) 템플릿 메소드 패턴 vs 전략 패턴

**템플릿 메소드 패턴**

- 알고리즘의 **전체 흐름을 상위 클래스(추상 클래스)의 템플릿 메서드**로 고정
- 알고리즘 중 일부 단계만 서브 클래스가 오버라이딩(재정의)하여 세부 구현을 담당
- 알고리즘 순서는 **상위 클래스에서 결정되어 변경 불가능**

**전략 패턴** 

- 알고리즘 자체를 전략 객체(Strategy)로 외부화하여 위임, 실행 주체는 전략 인터페이스를 통해 실행만 하며,구체적인 전략은 **객체로 주입하거나 런타임에 교체 가능**
- **오버라이딩이 아닌, 객체 교체를 통해 행동을 변경**

**공통점**

- 둘 다 알고리즘을 분리하고, 유연하게 교체할 수 있도록 한다.

**차이점**

- 템플릿 : 상위에서 알고리즘 흐름 고정, 메소드 교체 불가
- 전략 : 호출자가 직접 메소드 구성, 교체 가능
