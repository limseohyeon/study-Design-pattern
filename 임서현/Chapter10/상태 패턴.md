# 1. 상태 패턴 (State Pattern)

`상태 패턴(State Pattern)`은 객체 내부 상태가 바뀜에 따라 객체의 행동을 바꾸는 패턴이다.

상태를 별도의 클래스로 캡슐화 하고 객체에게 행동을 위임하기 때문에 내부 상태가 바뀔 때 행동이 바뀐다.

## 1.1 상태 패턴 구조

![image.png](attachment:c167c3e4-6686-486c-b07e-2bdf9916090c:image.png)

- Context : 상태를 가지고 있는 클래스
- State : 구상 상태 공용 인터페이스, 이를 통해 상태를 바꿔가며 사용 할 수 있다.
- ConcreateStateA, ConcreateB : 구상 상태 클래스로 행동을 각자 방식으로 구현한다.

## 1.2 상태 패턴 예제 - 뽑기 머신

![image.png](attachment:dc32c62a-d46e-41cd-adf4-68bdc8a8450f:image.png)

- **상태** : 동전 없음 / 동전 있음 / 알맹이 매진 / 알맹이 판매
- **행동** : 동전 투입 / 동전 반환 / 손잡이 돌림 / 알맹이 내보냄

상태를 각 class 로 정의, 행동을 구상 상태 클래스에서 각각 알맞게 구현하도록 한다.

**1. 4개의 상태를 캡슐화할 State 인터페이스 만들기**

```java
public interface State {
// 동전이 들어올 때 해야 할 일
public void insertQuarter();

// 동전을 반환할 때 해야 할 일
public void ejectQuarter();

// 손잡이가 돌아갔을 때 해야 할 일
public void turnCrank();

// 알맹이를 내보낼 때 해야 할 일
public void dispense();
}
```

**2. State 클래스 구현하기**

```java
public class NoQuarterState implements State {
    GumballMachine gumballMachine;

    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    public void insertQuarter() {
        System.out.println("동전을 넣으셨습니다.");
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }

    public void ejectQuarter() {
        System.out.println("동전을 넣어주세요.");
    }

    public void turnCrank() {
        System.out.println("동전을 넣어주세요.");
    }

    public void dispense() {
        System.out.println("동전을 넣어주세요.");
    }
}
```

```java
public class HasQuarterState implements State {
    GumballMachine gumballMachine;

    public HasQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    public void insertQuarter() {
        System.out.println("동전은 한 개만 넣어주세요.");
    }

    public void ejectQuarter() {
        System.out.println("동전이 반환됩니다.");
        gumballMachine.setState(gumballMachine.getNoQuarterState());
    }

    public void turnCrank() {
        System.out.println("손잡이를 돌리셨습니다.");
        gumballMachine.setState(gumballMachine.getSoldState());
    }

    public void dispense() {
        System.out.println("알맹이를 내보낼 수 없습니다.");
    }
}
```

```java
public class SoldState implements State {
    GumballMachine gumballMachine;

    public SoldState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    public void insertQuarter() {
        System.out.println("알맹이를 내보내고 있습니다.");
    }

    public void ejectQuarter() {
        System.out.println("이미 알맹이를 뽑으셨습니다.");
    }

    public void turnCrank() {
        System.out.println("손잡이는 한 번만 돌려주세요.");
    }

    public void dispense() {
        gumballMachine.releaseBall();
        if (gumballMachine.getCount() > 0) {
        	gumballMachine.setState(gumballMachine.getNoQuarterState());
        } else {
            System.out.println("Oops, out of gumballs!");
            gumballMachine.setState(gumballMachine.getSoldOutState());
        }
    }
}
```

```java
public class SoldOutState implements State {
    GumballMachine gumballMachine;

    public SoldOutState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    public void insertQuarter() {
        System.out.println("알맹이가 모두 품절되었습니다.");
    }

    public void ejectQuarter() {
        System.out.println("반환할 동전이 없습니다.");
    }

    public void turnCrank() {
        System.out.println("알맹이가 모두 품절되었습니다.");
    }

    public void dispense() {
        System.out.println("내보낼 알맹이가 없습니다.");
    }
}
```

**3. 뽑기 기계 구현하기**

```java
public class GumballMachine {
    State soldOutState;
    State noQuarterState;
    State hasQuarterState;
    State soldState;

    State state;
    int count = 0;

    public GumballMachine(int numberGumballs) {
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);

        this.count = numberGumballs;
        if (numberGumballs > 0) {
            state = noQuarterState;
        } else {
            state = soldOutState;
        }
    }

    public void insertQuarter() {
        state.insertQuarter();
    }

    public void ejectQuarter() {
        state.ejectQuarter();
    }

    public void turnCrank() {
        state.turnCrank();
        state.dispense();
    }

    void setState(State state) {
        this.state = state;
    }

    void releaseBall() {
        System.out.println("알맹이를 내보내는 중...");
        if (count > 0) {
            count -= 1;
        }
    }

    ...
}
```

상태 변경에 따라 동일한 행동을 다르게 동작할 수 있게 되었다.

**Q. 상태 변경을 Context에서 하면 안 되는가?**

→ 상태 전환이 고정 되어 있으면 가능, 동적으로 결정되면 상태 클래스 내부에서 처리하는 것이 좋다. 
     이때 상태 클래스간 의존성이 생기는데 getter()를 통해 최소화 하는 등 방법을 고려해야 한다.

### 정상성 점검하기

- SoldState와 WinnerState는 중복 코드가 많이 때문에 State를 추상 클래스로 만든다던가, 뽑기 기계는 display가 없으니 오류 response를 하나로 통일하던가 하는 변경을 고려해볼 수 있다.
- dispense()는 매번 호출되는데 필요에 따라 호출되도록 변경을 고려해볼 수 있다.
- 상태 전환 정보를 상태 클래스/context 어디에서 호출하는 것이 좋을까?
- Context 객체 인스턴스를 여러 개 만들게 된다면, 상태 인스턴스를 정적 인스턴스 변수로 만들어 공유하는 것이 좋다.

## 1.3 전략 패턴과 상태 패턴

전략 패턴과 상태 패턴의 클래스 다이어그램을 보면 그 구조가 매우 유사하고, 실제로도 그 구성이 거의 동일하다.

이 둘의 차이는, 사용하는 용도와 목적에 존재하며 그 중심에는 상태를 객체 스스로 변경하는가? 에 있다.

### 전략 패턴

```java
interface AttackStrategy { void attack(); }
	class SwordAttack implements AttackStrategy {
		public void attack() {
			System.out.println("검 공격");
		}
	}
class BowAttack implements AttackStrategy {
	public void attack() {
		System.out.println("활 공격");
		}
	}

class Character {
    private AttackStrategy strategy;
    public void setStrategy(AttackStrategy strategy) { this.strategy = strategy; }
    public void attack() { strategy.attack(); }
}
```

클라이언트가 전략을 선택하고 교체한다.

### 상태 패턴

```java
interface State {
	void pressButton();
}

class OnState implements State {
	public void pressButton() {
		System.out.println("불 끔");
	}
}

class OffState implements State {
	public void pressButton() {
		System.out.println("불 켬");
	}
}

class Light {
    private State state;
    public void setState(State state) { this.state = state; }
    public void pressButton() { state.pressButton(); }
}
```

객체 내부 상태 변화에 따라 교체된다.
