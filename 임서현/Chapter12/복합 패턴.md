# 1. 복합 패턴

---

복합 패턴이란 여러 패턴을 함께 사용해서 다양한 디자인 문제를 해결하는 방법이다.

## 1.2 복합 패턴 예제1 - 전략 + 어댑터 패턴

> 문제 기존의 오리 시뮬레이션 게임에 다른 패턴 적용해보기
> 

1. **전략 패턴 :** 모든 Duck 객체에서 Quackable 인터페이스 구현

```java
public interface Quackable {
    public void quack();
```

```java
public class MallardDuck implements Quackable {
    public void quack() {
        System.out.println("꽥꽥");
    }
}

public class DuckCall implements Quackable {
    public void quack() {
        System.out.println("꽉꽉");
    }
}
```

1. **어댑터 패턴 :** honk()을 사용하는 거위용 어댑터 추가

```java
public class Goose {
    public void honk() {
        System.out.println("끽끽");
    }
}
```

```java
public class GooseAdapter implements Quackable {
    Goose goose;

    public GooseAdapter(Goose goose) {
        this.goose = goose;
    }
    
    public void quack() {
        goose.honk();
    }
}
```

1. **시뮬레이터**

```java
public class DuckSimulator {
    public static void main(String[] args) {
        DuckSimulator simulator = new DuckSimulator();
        simulator.simulate();
    }

    void simulate() {
        Quackable mallardDuck = new MallardDuck();
        Quackable duckCall = new DuckCall();
        Quackable goose = new GooseAdapter(new Goose()); // Goose를 어댑터로 감싸줌
        
        System.out.println("\n오리 시뮬레이션 게임");

        simulate(mallardDuck);
        simulate(duckCall);
        simulate(goose);  // 거위지만 오리 메소드 실행 가능
    }

    void simulate(Quackable duck) {
        duck.quack();
    }
```

## 1.2 복합 패턴 예제2 - 데코레이터  + (전략 + 어댑터) 패턴

> **문제** 기존의 오리 시물레이션 게임에 꽥괘 소리 횟수 카운터 더하기
> 

1. **데코레이터 패턴** : count를 위한 데코레이터를 만들어 quack를 감싼다.

```java
public class QuackCounter implements Quackable {
    Quackable duck;
    static int numberOfQuacks; // 모든 객체에서 count해야해서 정적 static 사용

    public QuackCounter(Quackable duck) {
        this.duck = duck;
    }

    public void quack() {
        // quack() 메소드가 호출되면 해당 호출을 이 데코레이터의 Quackable 객체에 위임
        duck.quack();
        numberOfQuacks++;
    }

    public static int getQuacks() {
        return numberOfQuacks;
    }
}
```

1. **시뮬레이터 수정 :** QuackCounter 데코레이터로 감싼다.

```java
public class DuckSimulator {
    public static void main(String[] args) {
        DuckSimulator simulator = new DuckSimulator();
        simulator.simulate();
    }

    void simulate() {
        Quackable mallardDuck = new QuackCounter(new MallardDuck());
        Quackable duckCall = new QuackCounter(new DuckCall());
         // Quackable을 데코레이터로 감싸 줌
        
        Quackable goose = new GooseAdapter(new Goose());
       

        System.out.println("\n오리 시뮬레이션 게임");

        simulate(mallardDuck);
        simulate(duckCall);
        simulate(goose);

        System.out.println("오리가 소리 낸 횟수 : " + QuackCounter.getQuacks() + " 번");
    }

    void simulate(Quackable duck) {
        duck.quack();
    }
}
```

## 1.2 복합 패턴 예제3 - 데코레이터 + 팩토리 패턴

> **문제** 객체를 제대로 감싸야 사용할 수 있는 데코레이터 패턴을 보완하기
> 
1. **오리 생성을 팩토리에 위임**

```java
public abstract class AbstractDuckFactory{
	public abstract Quackable createMallardDuck();
	public abstract Quackable createRedHeadDuck();
	public abstract Quackable createDuckCall();
	public abstract Quackable createRubberDuck();
}
```

1. **데코레이터 캡슐화(= 데코레이터로 감싼 객체 반환)**

```java
public class CountingDuckFactory extends AbstractDuckFactory {
    public Quackable createMallardDuck() {
        return new QuackCounter(new MallardDuck());
    }
    
    public Quackable createDuckCall() {
        return new QuackCounter(new DuckCall());
    }
}
```

추가) 데코레이터가 없는 오리 생성 팩토리

```java
public class DuckFactory extends AbstractDuckFactory {
    public Quackable createMallarDuck() {
        return new MallardDuck();
    }
    public Quackable createDuckCall() {
        return new DuckCall();
    }
}
```

1. **팩토리를 사용하도록 시뮬레이터 변경**

```java
public class DuckSimulator {
    public static void main(String[] args) {
        DuckSimulator simulator = new DuckSimulator();
        AbstractDuckFactory duckFactory = new CountingDuckFactory();

        simulator.simulate(duckFactory); // simulate에 전달할 팩토리 생성 후 전달
    }

    void simulate(AbstractDuckFactory duckFactory) {
        Quackable mallardDuck = duckFactory.createMallardDuck();
        Quackable duckCall = duckFactory.createDuckCall();
        ...
    }
    
    void simulate(Quackable duck) {...}
}
```

## 1.3 복합 패턴 예제3 - 컴포지트 패턴

> **문제** 한 마리씩 관리하던 오리를 컬렉션/컬렉션의 부분 컬렉션으로 관리하기
> 

1. **컴포지트 패턴** : 오리 무리를 만들어 객체들로 구성된 컬렉션을 개별 객체와 같은 방식으로 다룬다.

```java
 public class Flock implements Quackable {
    List<Quackable> quackers = new ArrayList<Quackable>();

    public void add(Quackable quacker) {
        quackers.add(quacker);
    }

    public void quack() {
        Iterator<Quackable> it = quackers.iterator(); // 반복자 패턴
        while (it.hasNext()) {
            Quackable quacker = it.next(); // 순환문
            quacker.quack();
        }
    }
}
```

추가) Iterator은 반복자 패턴의 적용이다.

1. **시뮬레이터 수정**

```java
public class DuckSimulator {
   // main 메소드
   
    void simulate(AbstractDuckFactory duckFactory) {
        Quackable redheadDuck = duckFactory.createRedheadDuck();
        Quackable duckCall = duckFactory.createDuckCall();
        Quackable rubberDuck = duckFactory.createRubberDuck();
        Quackable gooseDuck = duckFactory.createGoose();
        
        System.out.println("\n오리 시뮬레이션 게임 : 무리 (+컴포지트)");

        Flock flockOfDucks = new Flock(); // 오리 무리

        flockOfDucks.add(redheadDuck);
        flockOfDucks.add(duckCall);
        flockOfDucks.add(rubberDuck);
        flockOfDucks.add(gooseDuck);

        Flock flockOfMallards = new Flock(); // 물오리 무리 (물오리만 포함)
        
        // 물오리 무리 생성
        Quackable mallardOne = duckFactory.createMallardDuck();
        Quackable mallardTwo = duckFactory.createMallardDuck();
        Quackable mallardThree = duckFactory.createMallardDuck();
        Quackable mallardFour = duckFactory.createMallardDuck();

        flockOfMallards.add(mallardOne);
        flockOfMallards.add(mallardTwo);
        flockOfMallards.add(mallardThree);
        flockOfMallards.add(mallardFour);

        flockOfDucks.add(flockOfMallards);  // 물오리 무리를 오리 무리에 추가

        System.out.println("오리 시뮬레이션 게임 : 전체 무리");
        simulate(flockOfDucks);

        System.out.println("오리 시뮬레이션 게임 : 물오리 무리");
        simulate(flockOfMallards);

        System.out.println("오리가 소리 낸 횟수 : " + QuackCounter.getQuacks() + " 번");
    }

    void simulate(Quackable duck) {
        duck.quack();
    }
}
```

## 1.4 복합 패턴 예제4 - 옵저버 패턴

> **문제** 오리들을 한 마리씩 실시간으로 추적하기
> 

1. **옵저버 인터페이스 등록하기**

```java
public interface QuackObservable {

    public void registerObserver(Observer observer); // 옵저버 등록
    public void notifyObservers(); // 옵저버에게 연락
}
```

1. **모든 Quackable에서 인터페이스를 구현하도록 설정하기**

```java
public interface Quackable extends QuackObservable{

    public void quack();
}
```

1. **옵저버를 위한 메소드 캡슐화하기**

이전 챕터에서는 모든 클래스에 QuackObservable을 일일이 등록했다. 이번에는 Observable 메소드를 별도의 class로 분리해 캡슐화 하고 이를 QuackObservble에 포함 시키도록 한다.

추가) Observer은 객체가 아니라 객체가 데이터를 받은 뒤 동작할 메소드들을 정의한 class다. 

```java
public class Observable implements QuackObservable {
    List<Observer> observers = new ArrayList<Observer>();
    QuackObservable duck;

    public Observable(QuackObservable duck) {
        this.duck = duck;
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void notifyObservers() {
        Iterator iterator = observers.iterator();
        while (iterator.hasNext()) {
            Observer observer = (Observer) iterator.next();
            observer.update(duck);
        }
    }
}
```

1. **Observer 보조 객체와 Quackable 클래스 결합하기**

```java
public class MallardDuck implements Quackable {
    Observable observable;

    public MallardDuck() {
        observable = new Observable(this);
    }

    public void quack() {
        System.out.println("꽥꽥");
        notifyObservers();
    }

    public void registerObserver(Observer observer) {
        observable.registerObserver(observer);
    }

    public void notifyObservers() {
        observable.notifyObservers();
    }
}
```

1. **옵저버 만들기**

```java
public interface Observer {
    public void update(QuackObservable duck);
}
```

```java
public class Quackologist implements Observer {
    public void update(QuackObservable duck) {
        System.out.println("꽥꽥학자: " + duck + "가 방금 소리냈다.");
    }
}
```

1. **시뮬레이터**

```java
public class DuckSimulator {
    public static void main(String[] args) {
        DuckSimulator simulator = new DuckSimulator();
        AbstractDuckFactory duckFactory = new CountingDuckFactory();
        simulator.simulate(duckFactory);
    }

    void simulate(AbstractDuckFactory duckFactory) {
        Flock flockOfDucks = new Flock();
        // 옵저버를 만들고
        Quackologist quackologist = new Quackologist();
        // 옵저버를 등록
        flockOfDucks.registerObserver(quackologist);

        simulate(flockOfDucks);
        System.out.println("오리가 소리 낸 횟수: " + QuackCounter.getQuacks() + " 번");
    }

    void simulate(Quackable duck) {
        duck.quack();
    }
}
```

# 2. Model-View-Controller

---

## 2.1 모델 - 뷰 - 컨트롤러 구조

- **모델(Model)** : 데이터와 비즈니스 로직을 담당
- **뷰(View)** : 사용자에게 보여지는 화면
- **컨트롤러(Controller)** : 사용자의 입력을 받아 모델과 뷰를 연결해 주는 중간 제어자

<aside>

**모델 - 뷰 - 컨트롤러 동작**

1. 사용자는 View를 통해 데이터 요청
2. Controller가 요청을 입력 받고 Model에 전달
3. Model은 요청을 처리 후 변경이 되었음을 View에 알림
4. View는 Model에게 상태 요청 후 변경 사항 가져옴
</aside>

**추가)**

- 경우에 따라 컨트롤러가 모델의 옵저버가 될 수 있다. 그 예로, 모델에 의해 사용자 인터페이스 컨트롤이 변경되는 경우가 있다.
- 모델 - 컨트롤러를 분리하는 이유
    - 뷰가 두 가지 동작을 하게 되면 코드가 복잡해진다.
    - 뷰와 모델이 밀접해지며 뷰를 재사용하기 어려워진다.

## 2.2 모델-뷰-컨트롤러에서 사용되는 패턴

- **옵저버 패턴** : `모델`은 옵저버 패턴을 사용해 **상태 변경**시 `뷰`와 `컨트롤러`에 알린다.
- **전략 패턴** : `컨트롤러`는 `뷰`의 행동으로 원하는 **동작에 따라 다른 컨트롤러로** 바꾸면 된다.
- **컴포지트 패턴** : `컨트롤러`가 `뷰`에게 화면을 갱신해달라고 요청하면 **최상위 뷰 구성요소에게 전달**함으로써 윈도우, 패널, 버튼 등 **하위 항목에 대한 처리를 수행**한다.
