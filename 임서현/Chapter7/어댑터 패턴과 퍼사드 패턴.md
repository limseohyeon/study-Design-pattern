# 1. 어댑터 패턴(Adapter Pattern)

`어댑터 패턴(Adapter Pattern)`란 특정 클래스 인터페이스를 클라이언트에서 요구한느 다른 인터페이스로 변환해 제공하는 패턴이다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 돕는다.

## 1.1 어댑터 패턴 구조

### 객체 어댑터

![image.png](attachment:7c47f0ef-b330-4aa4-b714-9a935e289b6c:image.png)

- 객체를 포함하고 메서드를 위임하는 방식
- 어댑터의 모든 서브클래스에서 어댑터를 사용할 수 있다.(= 어댑터를 implement하면 모든 클래스에서 객체를 넣어 사용할 수 있다)

### 클래스 어댑터

![image.png](attachment:1b38db0e-b3ee-4775-b6e9-ee75409a981d:image.png)

- 상속을 통한 메서드 오버라이드
- 특정 어댑티 클래스만 적용할 수 있으나(= 상속 받은 어댑티만 적용할 수 있음)
- 어댑티 전체를 다시 구현하지 않아도 되며 어댑티를 오버라이드 할 수 있다.

## 1.2 어댑터 패턴 예제

목표 : LegacyPrinter 을 NewPrinter처럼 사용할 수 있게 변경하도록 한다.

```java
// 이미 존재하는 클래스 (우리가 수정할 수 없음)
public class LegacyPrinter {
    public void oldPrint(String msg) {
        System.out.println("구식 프린터: " + msg);
    }
}

// 우리가 원하는 새로운 인터페이스
public interface NewPrinter {
    void print(String msg);
```

### 객체 어댑터 (Composition 기반)

```java
// 객체 어댑터는 '합성'을 사용한다 (has-a 관계)
public class PrinterAdapter implements NewPrinter {
    private LegacyPrinter legacyPrinter;

    public PrinterAdapter(LegacyPrinter legacyPrinter) {
        this.legacyPrinter = legacyPrinter;
    }

    public void print(String msg) {
        legacyPrinter.oldPrint(msg);  // 내부적으로 호출 위임
    }
}

```

### 클래스 어댑터 (상속 기반)

```java
// 클래스 어댑터는 '상속'을 사용한다 (is-a 관계)
public class PrinterClassAdapter extends LegacyPrinter implements NewPrinter {

    public void print(String msg) {
        oldPrint(msg);  // 부모의 메서드 사용
    }
}

```

# 2. 퍼사드 패턴(Facade Pattern)

---

퍼사드 패턴(Facade Pattern)은 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶는 패턴이다. 즉, 다양한 서브시스템/객체를 조합해서 하나의 단순한 메서드로 감싼다.

## 2.1 퍼사드 패턴 구조

```java
[Client]
   │
   ▼
[Facade] ───────────────┬─────────────┬─────────────┬─────────────┐
 |                     |             |             |             |
 ▼                     ▼             ▼             ▼             ▼
Projector         Screen       Amplifier       Lights        DvdPlayer
```

## 2.2 퍼사드 패턴 예제 - 홈시어터

영화를 보려면 아래와 같은 일련의 과정을 거쳐야한다.

<aside>

프로젝터 켜기

스크린 내리기

앰프 켜기

조명 끄기

DVD 플레이어 실행

</aside>

이 때 프로젝터, 스크린, 앰프, 조명, DVD 플래이어를 묶어 하나의 인터페이스를 제공하는 것이 퍼사드 패턴이다.

**<HomeTheaterFacade>**

```java
public class HomeTheaterFacade {
	// 구성 부분
    // 사용하고자 하는 서브시스템의 모든 구성 요소가 인스턴스 변수 형태로 저장됨
    Amplifier amp;
    Tuner tuner;
    StreamingPlayer player;
    Projector projector;
    TheaterLights lights;
    Screen screen;
    PopcornPopper popper;

    public HomeTheaterFacade(Amplifier amp,
    					Tuner tuner,
                        StreamingPlayer player,
                        Projector projector,
                        Screen screen,
                        TheaterLights lights,
                        PopcornPopper popper) {

    	this.amp = amp;
        this.tuner = tuner;
        this.player = player;
        this.projector = projector;
        this.screen = screen;
        this.lights = lights;
        this.popper = popper;
 	}
    // 기타 메소드
}
```

**<단순화된 통합 인터페이스>**

```java
public void watchMovie(String movie) {
	System.out.println("영화 볼 준비하는 중");
    popper.on();
    popper.pop();
    lights.dim(10);
    screen.down();
    projector.on();
    projector.wideScreenMode();
    amp.on();
    amp.setStreamingPlayer(player);
    amp.setSurroundSound();
    amp.setVolume(5);
    player.on();
    player.play(movie);
} // 복잡한 일을 하나의 메소드로 간단하게 처리
```

```java
public void endMovie(){
	System.out.println("홈시어터를 끄는 중");
    popper.off();
    lights.on();
    screen.up();
    projector.off();
    amp.off();
    player.stop();
    player.off();
}
```

**<테스트 클래스>**

```java
public class HomeTheaterTestDrive {
	public static void main(String[] args) {

        HomeTheaterFacade homeTheater = new HomeTheaterFacade(
        	amp, tuner, player, projector, screen, lights, popper);
        // 구성 요소 초기화
        // 테스트 중이므로 구성 요소 직접 생성
        // 보통은 클라이언트에 퍼사드가 주어지므로 직접 생성 안 해도 됨

      	homeTheater.watchMovie("가디언즈 오브 갤럭시");
        homeTheater.endMovie();
    }
}
```

## 1.3 최소 지식 원칙(Principle of Least Knowledge)

최소 지식 원칙이란 객체 사이의 상호작용은 될 수 있으면 아주 가까운 ‘친구’ 사이에서만 허용하는 편이 좋다는 원칙이다. 즉, 객체가 **자기 자신, 파라미터, 생성한 객체, 자신의 필드만** 알도록 **`.getA().getB().getC()` 이런 체이닝은 피하자**는 원칙

**친구를 만들지 않는 4가지 가이드라인**

아래 4가지만 친구로 둘 것!

- 객체 자체
    - 말 그대로 this
    - this.name, this.print)( 처럼 자기 자신 안에 있는 필드나 메소드
- 메소드에 매개변수로 전달된 객체
    - 외부에서 호출할 때 인자로 들어온 경우
    - doSumething(Customr customer) 안에서 customer.getName()
- 메소드를 생성하거나 인스턴스를 만든 객체
    - 메소드 내부에서 new로 만든 객체
    - Halper h = new Helper(); 호출 후 h.help()
- 객체에 속하는 구성 요소
    - 필드, 속성 같은 멤버 변수
    - this.cart.getTotal()

### 퍼사드 패턴과 최소 지식 원칙

퍼사드 내부에서도 **서브 시스템 객체에 깊게 들어가지 않고**, 한 단계만 접근하도록 설계해야 함
