# 1. 브리지 패턴(Bridge Pattern)

`브리지 패턴(Bridege Pattern)`은 추상 클래스와 구현 클래스를 분리해 독립적 변경을 가능하게 하는 패턴이다.

- `구현 클래스` : 외부에 노출되지 않는 로직
- `추상 클래스` ****: 외부에 노출되는 로직

- **활용법**
    - 구현 클래스와 추상 클래스의 동작이 다르지만, 서로 연결되어야 하는 상황에서 사용한다.
- **장점**
    - 객체를 단순하게 만들 수 있음
    - 사슬 변경을 통해 역할을 동적으로 추가하거나 제거 가능
- **단점**
    - 실행시 디버깅이 힘듦

## 1.2 브리지 패턴 구조

![image.png](attachment:5ffb4b63-4f59-44ec-b9b9-b671e4418d66:image.png)

### **구현 클래스**

- **`Implememter` (구현자 인터페이스/추상 클래스)**
    - 구현 계층 최상의 인터페이스, 즉 기능 인터페이스
    - 추상 메서드만 정의
- **`ComcreteImplementor`(구체 구현 클래스)**
    - Implementer을 실제로 구현
    - 구체적인 동작 담당

### **외부에 노출되는 로직 (= 추상 클래스)**

- **`Abstraction` (사용자에게 보이는 고수준 API)**
    - 추상 계층의 최상위 클래스
    - Implementeor을 `has-a` 구성, 내부적으로 위임
- **`RefinedAbstraction`(확장된 추상화 클래스)**
    - Acstraction을 상속 받아 추상 계층 기능을 확장하는 클래스

# 2. 빌더 패턴(Builder Pattern)

---

`빌더 패턴(Builder Pattern`)은 객체 생성 과정과 표현 방법을 분리해 다양한 구성의 인스턴스를 만드는 패턴이다.

- **활용법**
    - 생성 과정을 캡슐화한 별도의 빌더 메소드를 이용해 객체를 단계별로 조립할 수 있도록 지원한다.
- **장점**
    - 객체 생성 과정 캡슐화
- **단점**
    - 팩토리보다 객체를 만들 때 클라이언트에 관해 더 많이 알아야 함

```java
// 생성자 방식
Car car = new Car("현대", "검정", 4, true);

// 빌더 패턴
Car car = new Car.Builder()
    .brand("현대")
    .color("검정")
    .doors(4)
    .sunroof(true)
    .build();
```

# 3. 플라이웨이트 패턴(Flyweight Pattern)

---

`플라이웨이트 패턴(Flyweight Pattern)`은 재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화하는 구조 패턴이다. 즉, 캐시 개념을 패턴화한 것이다.

- **활용법**
    - 인스턴스가 많이 필요하나, 동일한 방식으로 제어해야 할 때 자주 사용된다.
- **장점**
    - 인스턴스 객체 개수를 줄려 메모리 절약 가능
    - 가상 객체 상태를 한 곳에 모아 관리 가능
- **단점**
    - 특정 인스턴스만 다른 인스턴스와 다른 행동 불가능

## 3.1 플라이웨이트 패턴 구조

![image.png](attachment:ab2bfe54-05b0-4552-9220-c4229d9ca4a3:image.png)

- **`Flyweight`** : 공유에 사용할 클래스들의 인터페이스
- **`ConcreteFlyweight`** : Flyweight 내용 정의, 실제 공유될 객체
- **`FlyweightFactory`** : Flyweight의 인스턴스 생성 or 공유 역할
- **`Client`** : 패턴 사용자

# 4. 책임 연쇄 패턴**(Chain of Responsibility Pattern)**

---

`책임 연쇄 패턴(Chain of Responsibility Pattern)`은 요청을 처리할 수 있는 객체들을 묶어두고, 순차적으로 전달하며 처리하는 패턴이다.

- **활용법**
    - 윈도우 시스템에서 마우스 클릭과 키보드 이벤트를 처리할 때 쓰인다.
- **장점**
    - 요청을 보낸 쪽과 받은 쪽 분리 가능
    - 객체는 사슬의 구조를 몰라도 됨
    - 사슬 객체를 변경해 역할을 추가하거나 제거할 수 있음
- **단점**
    - 요청이 반드시 수행된다는 보정이 없음
    - 디버깅 힘듦

![image.png](attachment:54f226fa-a151-4404-b6bc-a688280f70d1:image.png)

- `Handler` : 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스
- `Concrete handlers` : 요청을 실제로 처리하는 객체
- `Client` : 요청 전달 클라이언트

# 5. 인터프리터 패턴(Interpreter Pattern)

`인터프리터 패턴(Interpreter Pattern)`은 문법 규칙을 클래스로 표현하고, 해석(Interpreter)하는 구조를 만드는 패턴이다.

- **활용법**
    - 간단한 언어를 구현할 때 사용됨
- **장점**
    - 문법을 클래스로 표현해 언어를 쉽게 구현할 수 있음
- **단점**
    - 문법 규칙 개수가 많아지면 복잡해짐

## 5.1 인터프리터 패턴 구조

![image.png](attachment:68810b2c-026b-4de0-b651-1311a8aacd17:image.png)

- `Context`: Expression에서 사용하는 공통된 정보가 담겨있다, 문장을 저장하고 관리하는 클래스
- `Expression` : 표현하는 문법을 나타낸다.
- `TerminalExpression` : 종료되는 Expression
- `NonTerminalExpression` : Expression을 재귀적으로 참조하고 있는 Expression

# 6. 중재자 패턴 (Mediator Pattern)

`중재자 패턴(Mediator Pattern)`은 객체들 간의 복잡한 상호작용을 중재자 객체 하나로 캡슐화해서, 객체들이 직접 소통하지 않고 Mediator를 통해서만 소통하도록 만드는 패턴이다.

- **활용법**
    - 서로 연관된 GUI 구성 요소를 관리하는 용도로 많이 쓰인다.
- **장점**
    - 시스템과 객체를 분리해 재사용성을 향상시킴
    - 제어 로직 관리 수월
    - 객체 사이의 메시지를 줄이고 단순화 가능
- **단점**
    - 디자인을 잘 하지 못하면 복잡해 보일 수 있음

## 6.1 중재자 패턴 구조

![image.png](attachment:d313a35f-072b-4720-984d-f323072e6812:image.png)

- **`Mediator` (중재자 인터페이스)**
    - 객체 간의 소통을 정의하는 인터페이스
- **`ConcreteMediator` (구체 중재자)**
    - 실제 객체들을 관리하고, 메시지를 중개
- **`Colleague` (동료 클래스, 참가자)**
    - 원래 서로 통신해야 하는 객체들
    - Mediator를 참조해서, 필요한 동작을 요청

## 6.2 옵저버 패턴, 퍼사드 패턴과의 차이점

- **옵저버 패턴 vs 중재자 패턴**
    - 옵저버 : 1개의 publisher에 대해 N개의 subscriber가 존재하고 observer가 pulling이나 push 방식을 통해 관리
    - 중재자 : M개의 publisher와 N개의 subscriber 사이에서 1개의 mediator을 통해 통신
- **퍼사드 패턴 vs 중재자 패턴**
    - 퍼사드 : 단방향 통신
    - 중재자 : 양방향 통신

# 7. 메멘토 패턴

`메멘토 패턴(Memento Pattern)`은 객체의 상태를 저장해 두었다가, 나중에 해당 시점으로 복원할 수 있게 하는 패턴이다.

- **활용법**
    - 상태를 저장해 이전 상태로 복원할 때 사용
- **장점**
    - 저장된 상태를 객체와 다른 별도의 객체에 보관 가능
    - 객체 데이터를 계속해서 캡슐화된 상태로 유지할 수 있음
    - 복구 기능 구현 쉬움
- **단점**
    - 저장-복구에 시간이 할애됨

## 7.1 메멘토 패턴 구조

![image.png](attachment:c60e1d0a-2b6e-4334-834a-239cf0baea16:image.png)

1. `Originator`
    - 상태를 가진 원래 객체
    - 자신의 상태를 Memento로 저장하거나, Memento로부터 복원
2. **`Memento`**
    - 저장된 상태를 보관하는 객체 (불변, 캡슐화된 상태)
3. **`Caretaker`**
    - Memento를 관리(보관)하는 역할
    - Originator의 내부 상태를 직접 알지는 못함

# 8. 프로토타입 패턴(Prototype Pattern)

`프로토타입 패턴(Prototype Pattern)`은 **새로운 객체를 직접 생성하는 대신, 기존 객체를 복제(clone)해서 사용하는 생성 패턴이다.**

- **활용법**
    - 다양한 형식의 복잡한 객체 인스턴스를 새로 만들어야 할 때 사용
- **장점**
    - 클라이언트는 새로운 인스턴스를 만드는 과정을 몰라도 됨
    - 상황에 따라 새로 생성하는 것보다 복사하는 것이 효율적임
- **단점**
    - 상황에 따라 복사하는 것이 복잡

## 8.1 프로토타입 패턴 구조

![image.png](attachment:91909e2b-35b5-43a4-b9ed-18af058d23ab:image.png)

- **Prototype (프로토타입 인터페이스)**
    - 자신을 복제할 수 있는 메소드(`clone()`) 정의
- **ConcretePrototype (구체 프로토타입)**
    - 실제로 복제 기능을 구현한 클래스
- **Client**
    - `new` 대신 `clone()`을 호출해서 객체를 복제

# 9. 비지터 패턴(Visitor Pattern)

비지터 패턴(Visitor Pattern)은 데이터 구조(객체 집합)는 그대로 두고, 그 위에서 수행할 연산(동작)만 별도의 객체(Visitor)로 분리하는 행동 패턴이다.

- **장점**
    - 구조를 변경하지 않으면서도 복합 객체 구조에 새로운 기능을 추가할 수 있음
    - 비지터가 수행하는 기능과 관련된 코드를 한 곳에 모아둘 수 있음
- **단점**
    - 컬렉션 내의 모든 항목에 접근하는 트래버서가 있어 복합 구조를 변경하기 더 어려워짐
    ****

## 9.1 비지터 패턴 구조

![image.png](attachment:9d3f1728-9143-4c46-8cfe-3d40ab96c0be:63c237f1-f4c8-4234-b66f-49a2cf3d47fc.png)

- **Element (요소 인터페이스)**
    - `accept(Visitor v)` 메소드 정의
- **ConcreteElement (구체 요소)**
    - 실제 데이터 객체, `accept()` 안에서 Visitor 호출
- **Visitor (방문자 인터페이스)**
    - 요소마다 다른 연산을 정의 (예: `visit(Foo)`, `visit(Bar)`)
- **ConcreteVisitor (구체 방문자)**
    - 실제 연산을 구현하는 클래스

**추가)**

- **비지터 = 객체에 메소드를 원하는 대로 짜서 추가하는 것**
- **전략 = 만들어진 객체의 실행 방식을 원하는 대로 골라 쓰는 것**
