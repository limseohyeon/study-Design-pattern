# 1. 프록시 패턴(Proxy Pattern)

`프론시 패턴(Proxy Pattern)`은 특정 객체로의 접근을 제어하는 대리인을 제공하는 패턴이다.

### 프록시 패턴 종류

- 원격 프록시 : 원격 객체로의 접근을 제어한다.
- 가상 프록시(Virtual proxy) : 생성하기 힘든 자원으로의 접근을 제어할 수 있다.
- 보호 프록시(Protection proxy) : 접근 권한이 필요한 자원으로의 접근을 제어할 수 있다.

## 1.1 프록시 패턴 구조

![image.png](attachment:dfe8caa3-ccb8-48e0-9a08-cdebadcd67cf:image.png)

- `Subject` : Proxy와 RealSubject 모두 Subject 인터페이스를 구현한다. 이에 따라 모든 클라이언트가 Proxy를 RealSubject처럼 사용할 수 있다.
- `RealSubjec`t : 진짜 작업을 처리하는 객체
- `Proxy` : RealSubject 접근을 제어하는 객체
RealSubject의 레퍼런스가 들어있으며, 요청이 들어오면 RealSubject에 요청을 전달한다.

### 특징

1. 클라이언트는 항상 Proxt를 통해 RealSubject와 데이터를 주고받는다.
2. RealSubject가 들어갈 자리라면 어디든 Proxy가 들어갈 수 있다.(같은 인터페이스를 공유하기 때문)
3. RealSubject가 원격 시스템에서 돌아가거나, 객체 생성 비용이 많이 들 때 사용한다.

## 1.2 RMI

![image.png](attachment:aeba111c-fc76-4c34-b45c-6b09b8fb5a19:image.png)

`RMI`란 Java에서 제공하는 원격 함수 호출이다. 클라이언트에서 바로 서버로 접속 불가능한 환경일때, 가상환경에 인터페이스를 두고 통신하는 방식이다.

- 네트워킹 및 입출력 관련 코드를 제공
- 룩업(look up) : 클라이언트가 원격 객체를 찾아 접근할 때 쓸 수 있는 서비스
- 반드시 네트워크 및 입출력 기능이 필요하기 때문에 이에 따른 문제를 대비하고 있어야 함

### **RMI 용어**

- 스텁(Stub) : 클라이언트 보조 객체
- 스켈레톤(skeleton) : 서비스 보조 객체

### RMI를 이용한 원격 서비스 만들기 예제

1. **원격 인터페이스 만들기**
    
    ```java
    public interface MyRemote extend Remote{
    	public String sayHello() throws RemoteException;
    }
    ```
    
    - `java.rmi.Remote`를 확장한다. `Remote`는 별다른 메서드가 없는 표식용(marker)으로, RMI를 통해 원격 호출하게 될 것임을 알린다.
    - 모든 메소드는 `RemoteException`을 던지도록 선언해 발생할 문제에 대해 대비한다.
    - 원격 메소드의 return 값은 반드시 `원시 형식(primitive)` 또는 `Serializable` 형식을 선언한다.
2. **서비스 구현 클래스 만들기**
    
    ```java
    public Class MyRemoteImpl extends UnicastRemoteObject implements MyRemote{
    	
    	public MyRemoteImpl() throws RemoteException {}
    	
    	public String sayHello(){
    		return "Sever say, 'Hey'";
    	}
    	
    	public static void main (String[] args){
    		try{
    			MyRemote service = new MyRemoteImpl();
    			Naming.rebind("RemoteHello", service);
    		} catch(Exception ex){
    			ex.printStackTrace();
    		}
    	}
    }
    ```
    
    - `UnicastRemoteObject`를 확장한다. 이를 통해 원격 객체 역할이 가능한 객체로 기능한다.
    - `RemoteException`을 선언하는 생성자를 구현한다.
    슈퍼클래스 생성자가 예외를 던지면 서브 슬래스 생성자도 예외를 던져야 한다.
    - `rmi.Naming` 클래스에 있는 `rebind()` 정적 메소드를 이용해 서비스를 RMI 레지스트리에 등록한다.
3. **RMI 레지스트리 실행하기**
    - 터미널을 새로 띄어서 rmiregistry를 실행한다.
4. **원격 서비스 실행하기**
    - 다른 터미널을 열고 서비스를 실행한다.
5. **클라이언트 코드**
    
    ```java
    MyRemote service = (MyRemote) Naming.look("rmi://127.0.0.1/RemoteHello");
    ```
    
    - 클라이언트는 룩업(look) 을 통해 스텁 객체를 요청한다.
    - 가져온 스텁을 서비스 객체라 생각하고 메소드를 호출할 수 있다.

# 2. 프록시 패턴 예제 - 원격 프록시(뽑기 기계)

> *문제) GumballMachine에  알맹이 개수 재고와 현재 상태를 알 수 있는 기능을 추가하고 싶다.*
> 

<aside>

**[클라이언트 힙]**                         (Proxy)                                  **[서버 힙]** 

`클라이언트 객체` → `클라이언트 보조 객체`   —→   `서비스 보조 객체` → `서비스 객체`

</aside>

1. 클라이언트가 클라이언트 보조 객체의 메소드를 호출한다.
2. 클라이언트 보조 객체가 그 요청을 원격 객체에게 전달한다.
서버에 연락을 취하고, 메소드 호출에 관한 정보를 전달하고, 서버로부터 리턴 되는 정보를 기다린다.
3. 서비스 보조 객체가 Socket연결로 클라이언트 보조 객체로부터 요청을 받아오고 해석해 서비스 객체에 있는 진짜 메서드를 호출한다.
4. 서비스 보조 객체는 서비스로부터 리턴을 받아 클라이언트 보조 객체에게 전송한다.
5. 클라이언트 보조 객체는 정보를 해성해서 클라이언트 객체에 리턴한다.

1. 원격 인터페이스 만들기

```java
import java.rmi.*;
public interface GumballMachineRemote extends Remote {    
	public int getCount() throws RemoteException;   
	public String getLocation throws RemoteException;    
	public State getState() throws RemoteException;
}
```

2-1. 반환 데이터를 직렬화 가능한 형식으로 변경

```java
import java.io.*; 
public interface State extends Serializable {    
	public void insertQuarter();    
	public void ejectQuarter();    
	public void turnCrank();    
	public void dispense();
}
```

2-2. State객체에는 뽑기 기계 레퍼런스가 들어 있다. 해당 필드를 직렬화 하기 않기 위해 transient 키워드를 사용한다.

```java
public class NoQuarterState implements State {    
	transient GumballMachine gumballMachine;     
		// 기타 메소드
}
```

1. 서비스 구현 클래스 만들기

```java
import java.rmi.*;
import java.rmi.server.*; 
public class GumballMachine extends UnicastRemoteObject implements GumballMachineRemote{    
	// 인스턴스 변수들     
	public GumballMachine(String location, int numberGumballs) throws RemoteException {
	        // 생성자 코드    
	}     
	// getCount(), getState(), getLocation() 등 기타 메소드
}
```

1. RMI 레지스트리 등록하기

```java
import java.rmi.*; 
public class GumballMonitorTestDrive{    
public static void main(String[] args) {        
	String location = "rmi://seattle.mightygumball.com/gumballmachine";         
		try {            
			GumballMachineRemote machine = (GumballMachineRemote) Naming.lookup(location);            
			GumballMonitor monitor = new GumballMonitor(machine);        
			}catch (Exception e) {            
			e.printStackTrace();        
		}         
			monitor.report();   
		}
}
```

1. 클라이언트 코드

```java
import java.rmi.*; 
public class GumballMonitor{    
	GumballMachineRemote machine;     
		public GumballMonitor(GumballMachineRemote machine) {        
			this.machine = machine;    
		}     
		public void report() {        
			try {            
					// machine 객체의 Getter 메소드 이용해 위치, 재고, 상태 출력        
			} catch (Exception e) {            
					e.printStackTrace();        
		}    
	}
}
```

# 3. 프록시 패턴 예제 - 가상 프록시(앨범 커버)

`가상 프록시`는 실제 객체 생성 비용이 많이 들 때, 필요할 때까지 생성을 미루는 지연 로딩(Lazy Loading)에 사용된다.

**특징**

- 리소스 절약
- 필요할 때만 실제 객체 생성

> 목표) 실제 이미지를 가져오는 동안 가상 프록시의 미리보기 앨범 커버를 제공하기
> 
1. **인터페이스 만들기**

```java
interface Image {
    void display();
}
```

1. **실제 이미지**

```java
class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("이미지 로딩: " + filename);
    }

    public void display() {
        System.out.println("이미지 표시: " + filename);
    }
}
```

1. **가상 프록시**

```java
class ProxyImage implements Image {
    private String filename;
    private RealImage realImage;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    public void display() {
        if (realImage == null) { // 처음 호출될 때만 실제 객체 생성
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}
```

1. 클라이언트

```java
public class Main {
    public static void main(String[] args) {
        Image image = new ProxyImage("test.jpg");
        System.out.println("이미지 객체 생성 완료, 아직 로딩 안 함");
        image.display(); // 이 시점에만 실제 로딩
        image.display(); // 이미 로딩되어 재사용
    }
}
```

# 4. 프록시 패턴 예제 - 보호 프록시

`보호 프록시`는 실제 객체 접근 전에 권한 체크나 접근 제어를 수행한다.

**특징**

- 보안/권한 관리에 사용
- 실제 객체의 민감한 동작을 보호

> 목표) 실제 서비스 전에 권한 체크하기
> 
1. 인**터페이스**

```java
interface Service {
    void operation();
}

```

1. **실제 서비스**

```java
class RealService implements Service {
    public void operation() {
        System.out.println("실제 서비스 동작 실행");
    }
}
```

1. **보호 프록시**

```java
class ServiceProxy implements Service {
    private RealService realService = new RealService();
    private String userRole;

    public ServiceProxy(String userRole) {
        this.userRole = userRole;
    }

    public void operation() {
        if ("ADMIN".equals(userRole)) {
            realService.operation();
        } else {
            System.out.println("접근 거부: 권한 없음");
        }
    }
```

1. **클라이언트**

```java
public class Main {
    public static void main(String[] args) {
        Service adminProxy = new ServiceProxy("ADMIN");
        adminProxy.operation(); // 실행 가능

        Service userProxy = new ServiceProxy("USER");
        userProxy.operation(); // 접근 거부
    }
}
```
